defmodule PayDayLoan.CacheGenerator do
  # Macro implementation for PDL - should not be called from
  # the outside world.
  @moduledoc false

  @doc false
  @spec compile(Keyword.t) :: Macro.t
  def compile(opts) when is_list(opts) do
    callback_module = opts
    |> Keyword.get(:callback_module)
    |> determine_callback_module

    # build the config struct with defaults overridden by
    # values from opts
    pdl = opts
    |> merge_opts(%PayDayLoan{callback_module: callback_module})
    |> PayDayLoan.merge_defaults

    quoted_pdl = quoted_struct(pdl)

    [
      generate_pdl(quoted_pdl),
      generate_shortcuts()
    ]
  end

  # these are the main functions generated by the macro - they
  # define the pay_day_loan function which just returns the
  # pdl struct that was generated from the options
  defp generate_pdl(quoted_pdl) do
    quote location: :keep do
      @doc "PayDayLoan-generated cache configuration"
      @spec pay_day_loan :: PayDayLoan.t
      def pay_day_loan do
        unquote(quoted_pdl)
      end

      @doc "Alias of pay_day_loan/0"
      @spec pdl :: PayDayLoan.t
      defdelegate pdl, to: __MODULE__, as: :pay_day_loan
    end
  end

  # these are shortcut functions that basically just
  # delegate to PayDayLoan with the generated pdl as the
  # first argument
  #
  # there may be a way to do this using import
  defp generate_shortcuts do
    quote location: :keep do
      @doc """
      Synchronous pid fetcher

      Wraps PayDayLoan.get_pid/2
      """
      @spec get_pid(key :: PayDayLoan.key) ::
      {:ok, pid} | {:error, PayDayLoan.error}
      def get_pid(key) do
        PayDayLoan.get_pid(pdl(), key)
      end

      def get(key) do
        PayDayLoan.get(pdl(), key)
      end

      @doc """
      Returns the number of keys in cache

      Wraps PayDayLoan.cache_size/1
      """
      @spec size :: non_neg_integer
      def size do
        PayDayLoan.cache_size(pdl())
      end

      @doc """
      Request asynchronous load of one or more keys

      Wraps PayDayLoan.request_load/2
      """
      @spec request_load(PayDayLoan.key | [PayDayLoan.key]) :: :ok
      def request_load(key_or_keys) do
        PayDayLoan.request_load(pdl(), key_or_keys)
      end

      @doc """
      Returns a list of all keys in cache
      """
      @spec keys :: [PayDayLoan.key]
      def keys do
        PayDayLoan.keys(pdl())
      end

      @doc """
      Returns a list of pids in cache
      """
      @spec pids :: [pid]
      def pids do
        PayDayLoan.pids(pdl())
      end

      @spec values :: [term]
      def values do
        PayDayLoan.values(pdl())
      end

      @doc """
      Perform Enum.reduce/3 over all {key, pid} pairs
      """
      @spec reduce(term, (({PayDayLoan.key, pid}, term) -> term)) :: term
      def reduce(acc0, reducer)
      when is_function(reducer, 2) do
        PayDayLoan.reduce(pdl(), acc0, reducer)
      end

      @doc """
      Execute a callback with a pid if it is found.

      If no pid is found, not_found_callback is executed.  By default,
      not_found_callback returns `{:error, :not_found}`.
      """
      @spec with_pid(
        PayDayLoan.key,
                     ((pid) -> term),
      (() -> term)
      ) :: term
      def with_pid(
            key,
            found_callback,
            not_found_callback \\ fn -> {:error, :not_found} end
          ) do
        PayDayLoan.with_pid(pdl(), key, found_callback, not_found_callback)
      end

      @doc """
      Manually add a single key/pid to the cache.  Fails if the key is
      already in cache with a different pid.
      """
      @spec cache(PayDayLoan.key, pid) :: :ok | {:error, pid}
      def cache(key, pid) do
        PayDayLoan.cache(pdl(), key, pid)
      end
    end
  end

  defp determine_callback_module(nil) do
    message = "You must supply a callback module.  E.g.,:" <>
      " `use PayDayLoan, callback_module: MyCacheLoader`"
    raise ArgumentError, message: message
  end
  defp determine_callback_module({:__aliases__, _meta, module}) do
    Module.concat(module)
  end

  defp merge_opts(opts, pdl) do
    opts
    |> Keyword.delete(:callback_module) # already merged
    |> Enum.reduce(pdl, fn({k, v}, acc) ->
      Map.put(acc, k, v)
    end)
  end

  # turns a struct into a quoted expression
  defp quoted_struct(struct) do
    struct_module = struct.__struct__
    meta = {
      :__aliases__,
      [alias: false],
      Enum.map(Module.split(struct_module), &String.to_atom/1)
    }
    new_kv = struct |> Map.from_struct |> Enum.into([])
    {:%, [], [meta, {:%{}, [], new_kv}]}
  end
end
